<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>C++ Basics #4: Namespaces, Structs, Classes | Spore ModAPI SDK for creating C++ mods for Spore</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark.css" />
  <link rel="stylesheet" href="m-documentation.css" />
  <link rel="icon" href="Spore_ModAPI_Icon.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m"><img src="Spore_ModAPI_Icon.png" alt="" />Spore ModAPI <span class="m-thin">SDK for creating C++ mods for Spore</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Tutorials</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          C++ Basics #4: Namespaces, Structs, Classes
        </h1>
<section id="CppBasics4-Namespaces"><h2><a href="#CppBasics4-Namespaces">Namespaces</a></h2><p>When a program grows big, there are so many functions and variables that it&#x27;s almost certain some of them will end up having the same name. In order to avoid name collisions, C++ introduces <strong>namespaces</strong>. A namespace is a region of code that allows you to declare names without them colliding with identical names in other namespaces. To access something inside a namespace, you have to prefix it with <code>namespace_name::</code>. For example:</p><pre class="m-code"><span class="k">namespace</span><span class="w"> </span><span class="nn">A</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">myvar</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">myvar</span><span class="p">;</span><span class="w"></span></pre><p>Here there are no name collisions, because one is <code>myvar</code>, whereas the one inside the namespace is <code>A::myvar</code>. You can also nest namespaces inside other namespaces:</p><pre class="m-code"><span class="k">namespace</span><span class="w"> </span><span class="nn">A</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">B</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// This is A::B::myvar</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">myvar</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>For example, everything that belongs to the C++ Standard Library is inside the <code>std</code> namespace, so you access it like <code>std::vector</code>, <code>std::cin</code>,...</p><p>To avoid writing <code>::</code> all the time, there&#x27;s an instruction that &quot;removes&quot; the namespace scope. <code>using namespace A;</code>, where <code>A</code> is the namespace name, means you won&#x27;t have to write <code>A::</code> all the time, C++ will assume it. However, this must be used carefully: think that it&#x27;s defeating the reason namespaces were added in the first place. If this instruction is put inside a function, it will only affect inside that function.</p><aside class="m-note m-info"><h4>Note</h4><p>In the ModAPI SDK namespaces are very common. Everything related to editors is inside <code><a href="namespace_editors.html" class="m-doc">Editors</a>::</code>, everything related to graphics is inside <code><a href="namespace_graphics.html" class="m-doc">Graphics</a>::</code>,...</p></aside></section><section id="CppBasics4-Structs"><h2><a href="#CppBasics4-Structs">Structs</a></h2><p>Quite often a single variable is not enough to represent an object. Imagine you want to represent an employee: you might need to save its ID, its wage, its age,...</p><pre class="m-code"><span class="kt">int</span><span class="w"> </span><span class="n">joeAge</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">joeID</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">joeWage</span><span class="p">;</span><span class="w"></span>

<span class="c1">// What if we need another employee?</span>
<span class="kt">int</span><span class="w"> </span><span class="n">kateAge</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">kateID</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">kateWage</span><span class="p">;</span><span class="w"></span></pre><p>For situations like this, C++ introduces <strong>structs</strong> (short for structures). Structs let us create a new type with variables inside:</p><pre class="m-code"><span class="k">struct</span><span class="w"> </span><span class="nc">Employee</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">wage</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><aside class="m-note m-info"><h4>Note</h4><p>Don&#x27;t forget the semicolon <code>;</code> at the end! It&#x27;s one of the most common C++ errors.</p></aside><p>With that code we have created a new type, <code>Employee</code>, with those three variables; variables inside a structure are usually called <em>members</em> or <em>fields</em>. Note that <code>Employee</code> is a type, like <code>int</code> or <code>string</code>, but it&#x27;s not an object yet. We can create employee objects just like we would with any other type:</p><pre class="m-code"><span class="n">Employee</span><span class="w"> </span><span class="n">joe</span><span class="p">;</span><span class="w"></span>
<span class="n">Employee</span><span class="w"> </span><span class="n">kate</span><span class="p">;</span><span class="w"></span></pre><p>When we create a variable of an struct we call that an <em>instance</em> of the struct. We can access the members of a struct by using <code>.</code> and the member name:</p><pre class="m-code"><span class="n">Employee</span><span class="w"> </span><span class="n">joe</span><span class="p">;</span><span class="w"></span>
<span class="n">joe</span><span class="p">.</span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">27</span><span class="p">;</span><span class="w"></span>
<span class="n">joe</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">183902</span><span class="p">;</span><span class="w"></span>
<span class="n">joe</span><span class="p">.</span><span class="n">wage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1250.8</span><span class="p">;</span><span class="w"></span></pre><p>Having to initialize each value line per line can be too long. We can use <em>uniform initialization</em>, which allows us to assign all the values in order:</p><pre class="m-code"><span class="n">Employee</span><span class="w"> </span><span class="n">joe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="mi">183902</span><span class="p">,</span><span class="w"> </span><span class="mf">1250.8</span><span class="w"> </span><span class="p">};</span><span class="w"></span></pre></section><section id="CppBasics4-Classes"><h2><a href="#CppBasics4-Classes">Classes</a></h2><p>More advanced C++, such as in the ModAPI SDK, uses a coding technique known as <a href="https://en.wikipedia.org/wiki/Object-oriented_programming"><strong>object-oriented programming</strong></a>. It basically consists in representing everything as objects, with an object being a collection of attributes (for object <code>Person</code>, age, height, gender,...) and behaviours it can exhibit (walk, dance, talk,...).</p><p>In C++, we can represent those objects as a <code>class</code>:</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">Date</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p>Notice that the difference with structs is only in the <code>public:</code> line; if you want to know more about what it means, check <a href="https://www.learncpp.com/cpp-tutorial/83-public-vs-private-access-specifiers/">this learncpp.com tutorial</a>. Generally you will use classes, and structs only for very simple structures.</p><p>Classes can also have functions. A <em>member function</em> (a function inside of a class), sometimes also called <em>method</em>, has access to the variables of the class.</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">Date</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d/%d/%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">year</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p>Just as you can access member by using <code>.member_name</code>, you can call methods by using <code>.method_name(parameters)</code>:</p><pre class="m-code"><span class="n">Date</span><span class="w"> </span><span class="n">date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mo">02</span><span class="p">,</span><span class="w"> </span><span class="mo">02</span><span class="p">,</span><span class="w"> </span><span class="mi">2020</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">Date</span><span class="w"> </span><span class="n">date2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">1975</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="c1">// This prints &quot;2/2/2020&quot;</span>
<span class="n">date</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"></span>

<span class="c1">// This prints &quot;25/11/1975&quot;</span>
<span class="n">date2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"></span></pre><section id="CppBasics4-Classes-Constructors"><h3><a href="#CppBasics4-Classes-Constructors">Constructors &amp; Destructors</a></h3><p>By default, when we define a new instance of a class/struct, all its members receive a <em>default initialization</em>: if it&#x27;s an <code>int</code>, it gets assigned to 0, if it&#x27;s a <em>float</em>, it gets assigned to 0.0, etc</p><p>That might not be the behaviour we want. For example, if we want to create a <code>Color</code> class, we might want it to be a white color by default. We can do this with <strong>constructors</strong>: a function called when an object is initialized. Constructors are functions that don&#x27;t have a return type and have the same name as the class.</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">red</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">green</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// constructor</span>
<span class="w">    </span><span class="n">Color</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">255</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">255</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">255</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p>Inside constructors it&#x27;s common to use <em>initializer lists</em>, which are used to assign values to the class members:</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">red</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">green</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// constructor</span>
<span class="w">    </span><span class="n">Color</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">red</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">green</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">blue</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p>Constructors can also receive parameters; the constructor without parameters is the <em>default</em> constructor. It&#x27;s called like that because if no constructor is defined, that one is created by default.</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">red</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">green</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// constructor</span>
<span class="w">    </span><span class="n">Color</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">red</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">green</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">blue</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="n">Color</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">red</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">green</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">blue</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p>By default, the constructor is not called; this means that if we do <code>Color color;</code>, we cannot assume what the values will be: we say that the variable is <em>uninitialized</em>. There are multiple ways to call the constructor:</p><pre class="m-code"><span class="n">Color</span><span class="w"> </span><span class="nf">color</span><span class="p">();</span><span class="w"></span>
<span class="n">Color</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span><span class="p">();</span><span class="w"></span>

<span class="n">Color</span><span class="w"> </span><span class="nf">color</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span><span class="w"></span>
<span class="n">Color</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span><span class="w"></span></pre><aside class="m-note m-info"><h4>Note</h4><p>If you define constructors with parameters, the <em>default constructor</em> is not created by default. If you want it, you will have to declare it explicitly.</p></aside><p>It&#x27;s also possible to execute code when an object is destroyed, using a <strong>destructor</strong>. Destructors are defined like a contructor, but prefixed with <code>~</code>: <code><a href="_object_8h.html#a2e82adf9870bdb442cdcf2b3e01315b2" class="m-doc">~Color()</a></code></p></section><section id="CppBasics4-Classes-Static"><h3><a href="#CppBasics4-Classes-Static">Static members</a></h3><p>Sometimes, we will want to have members or methods in a class that don&#x27;t really belong to each instance, but to the class itself. Let&#x27;s see it with an example: imagine we want to define a variable that is the class name. That variable doesn&#x27;t belong to each instance, because all instances of the class must have the same class name. We can define such variables (and methods) using the <code>static</code> keyword.</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">Date</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">CLASS_NAME</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Date&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d/%d/%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">year</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p>If we define a <code>Date date;</code> instance, we won&#x27;t be able to do <code>date.CLASS_NAME</code>, because as we said the static variable does not belong to the instance, but to the class itself. We can access it like we accessed names inside a namespace: <code>Date::CLASS_NAME</code>.</p><aside class="m-note m-info"><h4>Note</h4><p>It wouldn&#x27;t make sense to assign <code>Date::CLASS_NAME</code> to anything else. We can use the keyword <code>const</code> to ensure that a variable cannot be changed.</p></aside></section><section id="CppBasics4-Classes-Separate"><h3><a href="#CppBasics4-Classes-Separate">Separating in header and source</a></h3><p>Remember in the last tutorial when we talked about the <a href="_cpp_basics3.html">importance of separating in header and source files</a>? We must do the same when defining a class.</p><p><em>Date.h</em>:</p><pre class="m-code"><span class="cp">#pragma once</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Date</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="n">Date</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">Date</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">CLASS_NAME</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p><em>Date.cpp</em>:</p><pre class="m-code"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Date.h&quot;</span><span class="cp"></span>

<span class="n">string</span><span class="w"> </span><span class="n">Date</span><span class="o">::</span><span class="n">CLASS_NAME</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Date&quot;</span><span class="p">;</span><span class="w"></span>

<span class="n">Date</span><span class="o">::</span><span class="n">Date</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">day</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">year</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">Date</span><span class="o">::</span><span class="n">Date</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">day</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">year</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Date</span><span class="o">::</span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d/%d/%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">year</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre></section></section><section id="CppBasics4-Polymorphism"><h2><a href="#CppBasics4-Polymorphism">Polymorphism</a></h2><p>Imagine you create a class for <code>Employer</code>, and another for <code>Employee</code>. They have different attributes and behaviours, yes, but they also have some of them in common: they both have an age, a name, etc as they both are a person. <strong>Polymorphism</strong> allows us to define a hierarchy between classes that helps us deal with this kind of situations.</p><p>Polymorphism consists in <strong>class inheritance</strong>: classes can inherit (aka <em>implement</em> or <em>extend</em>) from other classes, automatically gaining all itrs attributes and behaviours. Following the previous example, we would create a <code>Person</code> class, and then the <code>Employer</code> and <code>Employee</code> classes would inherit from <code>Person</code>:</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Employee</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Person</span><span class="w">  </span><span class="c1">// this means inherit from Person</span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">wage</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>If we declare an instance of employee, we will also be able to access the person fields; but if we declare a person, we won&#x27;t be able to access the wage, as that is a field for only certain types of person.</p><pre class="m-code"><span class="n">Employee</span><span class="w"> </span><span class="n">emp</span><span class="p">;</span><span class="w"></span>
<span class="n">emp</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Mike&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">emp</span><span class="p">.</span><span class="n">wage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1576.0</span><span class="p">;</span><span class="w"></span>

<span class="n">Person</span><span class="w"> </span><span class="n">person</span><span class="p">;</span><span class="w"></span>
<span class="n">person</span><span class="p">.</span><span class="n">wage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">  </span><span class="c1">// ERROR!</span></pre><p>It&#x27;s possible to extend more than one class. The extended classes are called <em>base classes</em>.</p><section id="CppBasics4-Polymorphism-Virtual"><h3><a href="#CppBasics4-Polymorphism-Virtual">Virtual methods</a></h3><p>Quite often subclasses won&#x27;t have the same behaviour as their base class. For example, the <code>Captain</code> class shouldn&#x27;t have the same <code>attack</code> behaviour than its base <code>Creature</code> class. C++ has a mechanic to <em>override</em> methods from a base class: <strong>virtual</strong> methods.</p><p>When a method in a base class is declared as <code>virtual</code>, it means subclasses can override the code of that method and give it its own behaviour. To override a method you just have to give it the same declaration: same name, same return type, same parameters, same specifiers.</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is class A&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is class B&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><pre class="m-code"><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="c1">// prints &quot;This is class A&quot;</span>
<span class="n">a</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"></span>

<span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="c1">// prints &quot;This is class B&quot;</span>
<span class="n">b</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"></span></pre><aside class="m-note m-info"><h4>Note</h4><p>The <code>override</code> keyword is optional. If you have it, the compiler will show you an error in case you declared your method wrong.</p></aside><p>There&#x27;s another concept to learn, <em>pure virtual</em> methods. A pure virtual method does not have code; it&#x27;s a way for the base class to tell that subclasses should provide their own implementation for those methods. If a class has a pure virtual method, you cannot create new instances of it; so subclasses will be forced to implement them.</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// pure virtual</span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">  </span><span class="c1">// ERROR! you haven&#39;t implemented print()</span></pre></section></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Spore ModAPI SDK for creating C++ mods for Spore. Created with <a href="https://doxygen.org/">Doxygen</a> 1.9.8 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
