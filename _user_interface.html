<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>User Interface | Spore ModAPI SDK for creating C++ mods for Spore</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark.css" />
  <link rel="stylesheet" href="m-documentation.css" />
  <link rel="icon" href="Spore_ModAPI_Icon.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m"><img src="Spore_ModAPI_Icon.png" alt="" />Spore ModAPI <span class="m-thin">SDK for creating C++ mods for Spore</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Tutorials</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          User Interface
        </h1>
        <p>How to load user interface elements to Spore and react to them.</p>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li><a href="#UserInterface-Loading">Loading SPUI layouts</a></li>
            <li>
              <a href="#UserInterface-Windows">Main operations with windows</a>
              <ul>
                <li><a href="#UserInterface-Windows-Get">Getting windows</a></li>
                <li><a href="#UserInterface-Windows-Add">Creating and adding windows</a></li>
                <li><a href="#UserInterface-Windows-Flags">Visible, enabled: flags and state</a></li>
                <li><a href="#UserInterface-Windows-Hierarchy">Working with the window hierarchy</a></li>
              </ul>
            </li>
            <li><a href="#UserInterface-Layouts">Window area and layouts</a></li>
            <li>
              <a href="#UserInterface-Drawables">Drawables</a>
              <ul>
                <li><a href="#UserInterface-Drawables-Image">Image Drawables</a></li>
              </ul>
            </li>
            <li>
              <a href="#UserInterface-Events">Procedures: reacting to events</a>
              <ul>
                <li><a href="#UserInterface-Events-Sending">Sending events</a></li>
              </ul>
            </li>
          </ul>
        </nav>
<p>In this tutorial we will explain the basic operations you need to know to create and react to user interface in Spore. The user interface system is called <a href="namespace_u_t_f_win.html" class="m-doc">UTFWin</a>, and everything you need is inside that namespace. For simplicity, we will assume through all this tutorial that <code>using namespace <a href="namespace_u_t_f_win.html" class="m-doc">UTFWin</a>;</code> is being used, so we don&#x27;t have to write <code><a href="namespace_u_t_f_win.html" class="m-doc">UTFWin</a>::</code> all the time.</p><p>First of all, we must discuss the two main elements in the Spore user interface: <code>IWindow</code> and <code>IWinProc</code>.</p><ul><li>Windows are elements that occupy a region of the screen. Images, text fields, buttons, sliders... they all implement <code>IWindow</code>.</li><li>Window procedures are used to give functionality to windows. They don&#x27;t have a visual representation.</li></ul><p>The windows are grouped creating a hierarchy: a window can have multiple children windows. A window can only have one parent window: the window that doesn&#x27;t have any parent is called the <em>root</em> window. For example, in the editor, the palette is a children of the root window; each of the pages is a children of the palette; each of the parts is a children of the page, etc. Windows are identified with a <code>controlID</code>, it&#x27;s like their name.</p><p>Windows can also have multiple window procedures. Procudres do not form a hierarchy: they do not have children nor parents, and the same procedure can be added to multiple windows. For example, the <code>EditorUI</code> class is a procedure (it implements <code>IWinProc</code>) and it&#x27;s added to all the buttons in the editor.</p><p>In Spore, layouts come in <code>.spui</code> (<strong>Sp</strong> ore <strong>U</strong> ser <strong>I</strong> nterface) files. You can view and edit them using <a href="https://emd4600.github.io/SporeModder-FX/">SporeModder FX</a>.</p><p>The <code>EnhancedColorPicker</code> is an example of a mod that uses the UTFWin module, you can see the <a href="https://github.com/emd4600/Spore-ModAPI/tree/master/Projects/Example%20Projects/EnhancedColorPicker">source code in GitHub</a>.</p><section id="UserInterface-Loading"><h2><a href="#UserInterface-Loading">Loading SPUI layouts</a></h2><p><code>.spui</code> layouts are represented in the code by the <a href="class_u_t_f_win_1_1_u_i_layout.html" class="m-doc">UILayout</a>. In order to load a SPUI file, you must declare an instance of that class (that is, without using <code>new</code>); generally that is stored inside a class, but it&#x27;s not necessary. Then, use the <a href="class_u_t_f_win_1_1_u_i_layout.html#a8ef338cb1264687208d7b2b96d43bd5f" class="m-doc">LoadByID()</a>, <a href="class_u_t_f_win_1_1_u_i_layout.html#ad7d5fb9fb159ad0899165a6223976a8c" class="m-doc">LoadByName()</a> or <a href="class_u_t_f_win_1_1_u_i_layout.html#adec18413234aed7ef1fee450e21747b2" class="m-doc">Load()</a> methods.</p><pre class="m-code"><span class="c1">// By name: it uses a unicode string, so you have to prefix it with &#39;u&#39;</span>
<span class="n">UILayout</span><span class="w"> </span><span class="n">layout</span><span class="p">;</span>
<span class="n">layout</span><span class="p">.</span><span class="n">LoadByName</span><span class="p">(</span><span class="sa">u</span><span class="s">&quot;EditorSharedUI&quot;</span><span class="p">);</span>

<span class="c1">// By id:</span>
<span class="n">UILayout</span><span class="w"> </span><span class="n">layout</span><span class="p">;</span>
<span class="n">layout</span><span class="p">.</span><span class="n">LoadByID</span><span class="p">(</span><span class="mh">0xF0F17503</span><span class="p">);</span></pre><p>By default, when a layout is loaded it&#x27;s added to the main window of the game. Very often that&#x27;s not what you will want, so you can change it by calling <code>SetParentWindow()</code>:</p><pre class="m-code"><span class="n">UILayout</span><span class="w"> </span><span class="n">layout</span><span class="p">;</span>
<span class="n">layout</span><span class="p">.</span><span class="n">LoadByName</span><span class="p">(</span><span class="sa">u</span><span class="s">&quot;EditorSharedUI&quot;</span><span class="p">);</span>

<span class="c1">// &#39;window&#39; is an IWindow*</span>
<span class="n">layout</span><span class="p">.</span><span class="n">SetParentWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span></pre></section><section id="UserInterface-Windows"><h2><a href="#UserInterface-Windows">Main operations with windows</a></h2><section id="UserInterface-Windows-Get"><h3><a href="#UserInterface-Windows-Get">Getting windows</a></h3><p>The main window of the game can be accessed with the <code>WindowManager</code>:</p><pre class="m-code"><span class="c1">// returns an IWindow*</span>
<span class="k">auto</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WindowManager</span><span class="p">.</span><span class="n">GetMainWindow</span><span class="p">();</span></pre><p>As was mentioned before, windows can be identified with a <code>controlID</code>. Not all windows have an ID, as you don&#x27;t always need to access a window. You can get the <code>IWindow*</code> object with a certain ID by calling the <code>FindWindowByID()</code> method, which can be called both in <code>UILayout</code> and in <code>IWindow</code>s:</p><pre class="m-code"><span class="n">UILayout</span><span class="w"> </span><span class="n">layout</span><span class="p">;</span>
<span class="n">layout</span><span class="p">.</span><span class="n">LoadByName</span><span class="p">(</span><span class="sa">u</span><span class="s">&quot;EditorSharedUI&quot;</span><span class="p">);</span>

<span class="c1">// get the window with ID 0xd04562fa</span>
<span class="k">auto</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">layout</span><span class="p">.</span><span class="n">FindWindowByID</span><span class="p">(</span><span class="mh">0xd04562fa</span><span class="p">);</span></pre></section><section id="UserInterface-Windows-Add"><h3><a href="#UserInterface-Windows-Add">Creating and adding windows</a></h3><p>Since <code>IWindow</code> is an abstract interface, you cannot create new instances of it directly. Instead, you have to instatiate one of the implementations (standard window, button, etc). For now, the ModAPI SDK only supports the <code>Window</code> class. You can use the <code>AddWindow()</code> and <code>RemoveWindow()</code> methods of <code>IWindow</code> to change the hierarchy:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Window</span><span class="p">();</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetControlID</span><span class="p">(</span><span class="n">id</span><span class="p">(</span><span class="s">&quot;MyPanel&quot;</span><span class="p">));</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetFillColor</span><span class="p">(</span><span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">);</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetArea</span><span class="p">({</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">250</span><span class="p">,</span><span class="w"> </span><span class="mi">250</span><span class="w"> </span><span class="p">});</span>

<span class="n">WindowManager</span><span class="p">.</span><span class="n">GetMainWindow</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span></pre><p>When you use <code>AddWindow()</code>, the window gets removed from its previous parent, if any.</p><p>If you want to store a pointer to a window in a class, it&#x27;s recommended to use an intrusive pointer (<code>IWindowPtr</code>)</p></section><section id="UserInterface-Windows-Flags"><h3><a href="#UserInterface-Windows-Flags">Visible, enabled: flags and state</a></h3><p>Certain properties in a window are controlled by its <strong>flags</strong>: a number where every bit means one thing. The two main flags control visibility and whether the button is enabled or disabled: <code>kWinFlagVisible</code> and <code>kWinFlagEnabled</code>. You can get the flags with <code>GetFlags()</code>, then use the bitwise AND operation to check them:</p><pre class="m-code"><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">GetFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">kWinFlagEnabled</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// This code only gets executed if the window is enabled</span>
<span class="p">}</span></pre><p>You can use <code>SetFlag()</code> to change the value of one of the flags:</p><pre class="m-code"><span class="c1">// Hide the window</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetFlag</span><span class="p">(</span><span class="n">kWinFlagVisible</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span></pre><p>The state of a window are also flags, but control whether the player is hovering the window, clicking it, etc. Not all window types support it:</p><pre class="m-code"><span class="c1">// Is the player hovering the button?</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">button</span><span class="o">-&gt;</span><span class="n">GetState</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">kStateHover</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="p">}</span></pre></section><section id="UserInterface-Windows-Hierarchy"><h3><a href="#UserInterface-Windows-Hierarchy">Working with the window hierarchy</a></h3><ul><li>As explained before, all windows (except root ones) have a parent window, which you can get by calling <code>GetParent()</code>.</li><li>You can use <code>AddWindow()</code> to add new children windows, <code>RemoveWindow()</code> to remove children windows.</li><li><code>window1-&gt;IsAncestorOf(window2)</code> will tell you if <code>window2</code> is a children of <code>window1</code>. This works recursively, meaning that this is checked for all children of <code>window1</code> as well.</li><li>Use <code>BringToFront(window)</code> to ensure that the children window <code>window</code> is displayed in front of all other children. Similarly, <code>SendToBack(window)</code> will make it display below all other children.</li><li><p>It&#x27;s possible to iterate through all children of a window:</p><pre class="m-code"><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">window</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>

<span class="p">}</span></pre></li><li>If you want to destroy a window, as well as all it&#x27;s children: <code class="m-code"><span class="n">window</span><span class="o">-&gt;</span><span class="n">GetParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">DisposeWindowFamily</span><span class="p">(</span><span class="n">window</span><span class="p">);</span></code></li></ul></section></section><section id="UserInterface-Layouts"><h2><a href="#UserInterface-Layouts">Window area and layouts</a></h2><p>Windows occupy a region of the screen. Regarding to this we can differentiate two different values: the <code>area</code> and the <code>realArea</code>. Both this properties are defined by a <code>Rectangle</code>, which is four float values: X &amp; Y coordinates of the top-left corner, X &amp; Y coordinates of the bottom-right corner.</p><ul><li>The <code>realArea</code> is the real coordinates.</li><li>The <code>area</code> is relative to the parent, and it can be altered by window procedures.</li></ul><p>Therefore, the <code>area</code> are only used as parameters; if you want to know the real position and size of a window, you have to use <code>GetRealArea()</code>. There exists a special type of window procedures that are designed to change their area depending on their parent; those procedures are called <strong>layouts</strong>. Layouts use the <code>area</code> property and the parent of a window to adapt and change the <code>realArea</code>. Why is that useful? Let&#x27;s see it with a quick example: imagine you want a window in the center of the screen. What coordinates is that, (400, 300)? You cannot know, because it depends on the resolution. Layouts allow you to do this easily. There are two layout classes:</p><ul><li><a href="class_u_t_f_win_1_1_simple_layout.html" class="m-doc">SimpleLayout</a>: It makes the <code>area</code> coordinates be relative to the parent real area. It does so with a proeprty called <code>anchor</code> (similar to other UI designers) which defines the sides of the parent the window is attached to.</li><li><a href="class_u_t_f_win_1_1_proportional_layout.html" class="m-doc">ProportionalLayout</a>: Similar to the SimpleLayout, but this one uses proportions.</li></ul><p>Let&#x27;s see it with examples. We want to create a window that is <em>80x50</em> in size (widht 80 and height 50) and is always attached to the bottom right corner of its parent. We can do it with a SimpleLayout:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Window</span><span class="p">();</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetFillColor</span><span class="p">(</span><span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">);</span>

<span class="c1">// With this, the &#39;area&#39; of our window will be relative to the bottom right of its parent</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">AddWinProc</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">SimpleLayout</span><span class="p">(</span><span class="n">kAnchorBottom</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">kAnchorRight</span><span class="p">));</span>

<span class="c1">// Since now the &#39;area&#39; origin of coordinates starts at the bottom right, we have to use</span>
<span class="c1">// negative coordinates to move it inside our parent</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetArea</span><span class="p">({</span><span class="w"> </span><span class="mi">-80</span><span class="p">,</span><span class="w"> </span><span class="mi">-50</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">});</span>

<span class="n">WindowManager</span><span class="p">.</span><span class="n">GetMainWindow</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span></pre><p>Another example: we want to create a window that is <em>200x100</em> in size and is always centered in the screen. We can do it with the ProportionalLayout:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Window</span><span class="p">();</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetFillColor</span><span class="p">(</span><span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">);</span>

<span class="c1">// Each of this values means that the left side starts at 50% of the parent width, </span>
<span class="c1">// the top side starts at 50% of parent height, etc</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">AddWinProc</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ProportionalLayout</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">));</span>

<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetArea</span><span class="p">({</span><span class="w"> </span><span class="mi">-100</span><span class="p">,</span><span class="w"> </span><span class="mi">-50</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="p">});</span>

<span class="n">WindowManager</span><span class="p">.</span><span class="n">GetMainWindow</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span></pre><p>Try adding these codes inside a cheat and play with it a little.</p><p>Windows have some extra methods to modify the area: <code>SetLocation()</code>, <code>SetSize()</code>. There are also equivalents that set these properties after the layouts have been applied: <code>SetLayoutArea()</code>, <code>SetLayoutLocation()</code>, <code>SetLayoutSize()</code>.</p></section><section id="UserInterface-Drawables"><h2><a href="#UserInterface-Drawables">Drawables</a></h2><p>Windows have two basic parameters that control its appearance: the <em>fill</em> and the <em>shade</em> colors. The <em>fill</em> color is rendered in the background, filling all the area of the window. The <em>shade</em> color is a tint that changes how all the window is rendered.</p><p>Additionally, windows can use drawables to render more advanced things. Classes that implement <a href="class_u_t_f_win_1_1_i_drawable.html" class="m-doc">UTFWin::<wbr />IDrawable</a> can be added to a window with <code>SetDrawable()</code>; a single window can have only one drawable. Also keep in mind that not all drawables are valid for all windows; you cannot add a <code>SliderDrawable</code> to a button.</p><p><code>IDrawable</code>s can also be inherited in order to create new drawables. For example, the game minimap is a modified drawable that renders an image generated in the code.</p><section id="UserInterface-Drawables-Image"><h3><a href="#UserInterface-Drawables-Image">Image Drawables</a></h3><p>The most common drawable is the <code>ImageDrawable</code>, which just renders an image into the window. Even though you can configurate the drawable itself, there&#x27;s also a method that creates the window, loads the image and creates the drawable all in one:</p><pre class="m-code"><span class="c1">// The window will be added to &#39;parentWindow&#39;</span>
<span class="c1">// It&#39;s {instance, type, group}</span>
<span class="k">auto</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IImageDrawable</span><span class="o">::</span><span class="n">AddImageWindow</span><span class="p">({</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="s">&quot;cultural_turret&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">TypeIDs</span><span class="o">::</span><span class="n">png</span><span class="p">,</span><span class="w"> </span><span class="mh">0x65928944</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">parentWindow</span><span class="p">);</span></pre></section></section><section id="UserInterface-Events"><h2><a href="#UserInterface-Events">Procedures: reacting to events</a></h2><p>One of the most common uses of the UTFWin module is reacting to UI events. User interface events are caleld <strong>messages</strong>, and are represented by the <a href="class_u_t_f_win_1_1_message.html" class="m-doc">UTFWin::<wbr />Message</a> class; there are messages for everything that can happen in the UI: mouse and keyboard input, clicking buttons, displaying elements, editing text,...</p><p><strong>Window procedures</strong> (<code>IWinProc</code>) are classes that are used to react to events in windows. To implement your own window procedure you have to create a new class that inherits <code>IWinProc</code>, and override its two main methods:</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">MyListener</span><span class="w"> </span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">IWinProc</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">GetEventFlags</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">HandleUIMessage</span><span class="p">(</span><span class="n">IWindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="p">};</span></pre><p>You can also create a basic window procedure using the *&quot;ModAPI Window Procedure&quot;* item template.</p><p>Now, what code goes in each of those two methods? <code>GetEventFlags()</code> must return a combination of flags that tells which kind of events this window procedure is listening to. The available flags are documented at <a href="namespace_u_t_f_win.html#a53dcde7b7ffd3f5d6b53da77f5649044" class="m-doc">UTFWin::<wbr />EventFlags</a>.</p><pre class="m-code"><span class="kt">int</span><span class="w"> </span><span class="nf">MyListener::GetEventFlags</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">kEventFlagBasicInput</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">kEventFlagAdvanced</span><span class="p">;</span>
<span class="p">}</span></pre><p>The other method is the important one. <code>HandleUIMessage()</code> is called every time a message is received in a window that has this procedure added. The return value is important: it&#x27;s whether the message has been handled or not. This means that if the method returns <code>true</code>, no other window will receive this message.</p><pre class="m-code"><span class="kt">bool</span><span class="w"> </span><span class="nf">MyListener::HandleUIMessage</span><span class="p">(</span><span class="n">IWindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// by default, just return false since we didn&#39;t handle the message</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></pre><p>The <code>window</code> parameter is the window that is calling this procedure, but not necessarily the window where the event was generated. This is because the same procedure can be added to multiple windows. You can get the window that generated the event with <code>message.source</code>. You can also use the method <code>IsType()</code> to know the type of message. The <code>message</code> parameter contains information related to the event, but not all data is always valid; it depends in the event type. For example, you can only use <code>message.Key</code> if the message was a key pressed, key released, etc.</p><p>For example, this code will print something to the console if a button with the ID &quot;ExitButton&quot; was clicked:</p><pre class="m-code"><span class="kt">bool</span><span class="w"> </span><span class="nf">MyListener::HandleUIMessage</span><span class="p">(</span><span class="n">IWindow</span><span class="o">*</span><span class="w"> </span><span class="n">pWindow</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">IsType</span><span class="p">(</span><span class="n">kMsgButtonClick</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">GetControlID</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="s">&quot;ExitButton&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">App</span><span class="o">::</span><span class="n">ConsolePrintF</span><span class="p">(</span><span class="s">&quot;You pressed the exit button&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// We did handled the message, return true</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// By default, just return false since we didn&#39;t handle the message</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></pre><p>In addition to window procedures, there are the <a href="class_u_t_f_win_1_1_interactive_win_proc.html" class="m-doc">UTFWin::<wbr />InteractiveWinProc</a> and <a href="class_u_t_f_win_1_1_interactive_window.html" class="m-doc">UTFWin::<wbr />InteractiveWindow</a> classes. These classes extend <code>IWinProc</code> and <code>IWindow</code> respectively and define methods that allow to easily handle messages. Instead of handling everything in a big <code>HandleUIMessage()</code> method, in these classes you can extend the method that listens to the type of event you want, for example <code><a href="_object_8h.html#a2e82adf9870bdb442cdcf2b3e01315b2" class="m-doc">OnMouseClick()</a></code>.</p><section id="UserInterface-Events-Sending"><h3><a href="#UserInterface-Events-Sending">Sending events</a></h3><p>It is possible to programatically generate an event. This can be used, for example, to make the game believe certain button was clicked.</p><pre class="m-code"><span class="n">Message</span><span class="w"> </span><span class="n">message</span><span class="p">;</span>
<span class="n">message</span><span class="p">.</span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">window</span><span class="p">;</span><span class="w">  </span><span class="c1">// Which window generated this event?</span>
<span class="n">message</span><span class="p">.</span><span class="n">eventType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kMsgMouseDown</span><span class="p">;</span><span class="w">  </span><span class="c1">// What type of event is it?</span>
<span class="c1">// Now we want to set the specific parameters (i.e. the position that was clicked,...).</span>
<span class="n">message</span><span class="p">.</span><span class="n">Mouse</span><span class="p">.</span><span class="n">mouseState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kMouseLeftButtonDown</span><span class="p">;</span>
<span class="n">message</span><span class="p">.</span><span class="n">Mouse</span><span class="p">.</span><span class="n">mouseX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span>
<span class="n">message</span><span class="p">.</span><span class="n">Mouse</span><span class="p">.</span><span class="n">mouseY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">276</span><span class="p">;</span>

<span class="c1">// Now just send the message</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SendMsg</span><span class="p">(</span><span class="n">message</span><span class="p">);</span></pre></section></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Spore ModAPI SDK for creating C++ mods for Spore. Created with <a href="https://doxygen.org/">Doxygen</a> 1.9.8 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
